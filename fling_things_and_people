loadstring(game:HttpGet("https://raw.githubusercontent.com/SaulGoodmanScripter/Utilit/refs/heads/main/Loader_Ui"))()
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/SaulGoodmanScripter/library/refs/heads/main/The%20main%20code"))()
local Window = Library:Window({
    Title = "FTAP Script",
    Desc = "Fling things and people",
    Icon = 4483362458,
    Theme = "Galaxy",
    Config = {
        Keybind = Enum.KeyCode.RightControl,
        Size = UDim2.new(0, 500, 0, 350)
    },
    CloseUIButton = {
        Enabled = true,
        Text = "Close/Open"
    }
})

local function Notify(title, desc, time)
    Window:Notify({
        Title = title,
        Desc = desc,
        Time = time or 3
    })
end

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")
local GrabEvents = ReplicatedStorage:WaitForChild("GrabEvents")
local MenuToys = ReplicatedStorage:WaitForChild("MenuToys")
local CharacterEvents = ReplicatedStorage:WaitForChild("CharacterEvents")
local SetNetworkOwner = GrabEvents:WaitForChild("SetNetworkOwner")
local Struggle = CharacterEvents:WaitForChild("Struggle")
local CreateLine = GrabEvents:WaitForChild("CreateGrabLine")
local DestroyLine = GrabEvents:WaitForChild("DestroyGrabLine")
local DestroyToy = MenuToys:WaitForChild("DestroyToy")
local localPlayer = Players.LocalPlayer
local playerCharacter = localPlayer.Character or localPlayer.CharacterAdded:Wait()
localPlayer.CharacterAdded:Connect(function(character)
    playerCharacter = character
end)

-- Переменные
local AutoRecoverDroppedPartsCoroutine
local reloadBombCoroutine
local antiExplosionConnection
local poisonAuraCoroutine
local deathAuraCoroutine
local poisonCoroutines = {}
local strengthConnection
local autoStruggleCoroutine
local autoDefendCoroutine
local anchoredParts = {}
local fireAllCoroutine
local connections = {}
local renderSteppedConnections = {}
local ragdollAllCoroutine
local crouchJumpCoroutine
local crouchSpeedCoroutine
local anchorGrabCoroutine
local poisonGrabCoroutine
local ufoGrabCoroutine
local burnPart
local fireGrabCoroutine
local noclipGrabCoroutine
local antiKickCoroutine
local kickGrabConnections = {}
local blobmanCoroutine
local lighBitSpeedCoroutine
local lightbitpos = {}
local lightbitparts = {}
local lightbitcon
local lightbitcon2
local lightorbitcon
local bodyPositions = {}
local alignOrientations = {}
local decoyOffset = 15
local stopDistance = 5
local circleRadius = 10
local circleSpeed = 2
local auraToggle = 1
local crouchWalkSpeed = 50
local crouchJumpPower = 50
local kickMode = 1
local auraRadius = 20
local lightbit = 0.3125
local lightbitoffset = 1
local lightbitradius = 20
local usingradius = lightbitradius

local followMode = true
local toysFolder = workspace:FindFirstChild(localPlayer.Name.."SpawnedInToys")
local playerList = {}
local selection 
local blobman 
local platforms = {}
local ownedToys = {}
local bombList = {}
_G.ToyToLoad = "BombMissile"
_G.MaxMissiles = 9
_G.BlobmanDelay = 0.005
_G.strength = 400

-- Функции
local function isDescendantOf(target, other)
    local currentParent = target.Parent
    while currentParent do
        if currentParent == other then
            return true
        end
        currentParent = currentParent.Parent
    end
    return false
end

local function DestroyT(toy)
    local toy = toy or toysFolder:FindFirstChildWhichIsA("Model")
    DestroyToy:FireServer(toy)
end

local function getDescendantParts(descendantName)
    local parts = {}
    for _, descendant in ipairs(workspace.Map:GetDescendants()) do
        if descendant:IsA("Part") and descendant.Name == descendantName then
            table.insert(parts, descendant)
        end
    end
    return parts
end

local poisonHurtParts = getDescendantParts("PoisonHurtPart")
local paintPlayerParts = getDescendantParts("PaintPlayerPart")

local function updatePlayerList()
    playerList = {}
    for _, player in ipairs(Players:GetPlayers()) do
        table.insert(playerList, player.Name)
    end
end

local function onPlayerAdded(player)
    table.insert(playerList, player.Name)
end

local function onPlayerRemoving(player)
    for i, name in ipairs(playerList) do
        if name == player.Name then
            table.remove(playerList, i)
            break
        end
    end
end

Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)

for i, v in pairs(localPlayer:WaitForChild("PlayerGui"):WaitForChild("MenuGui"):WaitForChild("Menu"):WaitForChild("TabContents"):WaitForChild("Toys"):WaitForChild("Contents"):GetChildren()) do
    if v.Name ~= "UIGridLayout" then
        ownedToys[v.Name] = true
    end
end

local function getNearestPlayer()
    local nearestPlayer
    local nearestDistance = math.huge

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (playerCharacter.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distance < nearestDistance then
                nearestDistance = distance
                nearestPlayer = player
            end
        end
    end

    return nearestPlayer
end

local function cleanupConnections(connectionTable)
    for _, connection in ipairs(connectionTable) do
        connection:Disconnect()
    end
    connectionTable = {}
end

local function spawnItem(itemName, position, orientation)
    task.spawn(function()
        local cframe = CFrame.new(position)
        local rotation = Vector3.new(0, 90, 0)
        ReplicatedStorage.MenuToys.SpawnToyRemoteFunction:InvokeServer(itemName, cframe, rotation)
    end)
end

local function arson(part)
    if not toysFolder:FindFirstChild("Campfire") then
        spawnItem("Campfire", Vector3.new(-72.9304581, -5.96906614, -265.543732))
    end
    local campfire = toysFolder:FindFirstChild("Campfire")
    burnPart = campfire:FindFirstChild("FirePlayerPart") or campfire.FirePlayerPart
    burnPart.Size = Vector3.new(7, 7, 7)
    burnPart.Position = part.Position
    task.wait(0.3)
    burnPart.Position = Vector3.new(0, -50, 0)
end

local function handleCharacterAdded(player)
    local characterAddedConnection = player.CharacterAdded:Connect(function(character)
        local hrp = character:WaitForChild("HumanoidRootPart")
        local fpp = hrp:WaitForChild("FirePlayerPart")
        fpp.Size = Vector3.new(4.5, 5, 4.5)
        fpp.CollisionGroup = "1"
        fpp.CanQuery = true
    end)
    table.insert(kickGrabConnections, characterAddedConnection)
end

local function kickGrab()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = player.Character.HumanoidRootPart
            if hrp:FindFirstChild("FirePlayerPart") then
                local fpp = hrp.FirePlayerPart
                fpp.Size = Vector3.new(4.5, 5.5, 4.5)
                fpp.CollisionGroup = "1"
                fpp.CanQuery = true
            end
        end
        handleCharacterAdded(player)
    end

    local playerAddedConnection = Players.PlayerAdded:Connect(handleCharacterAdded)
    table.insert(kickGrabConnections, playerAddedConnection)
end

local function grabHandler(grabType)
    while true do
        local success, err = pcall(function()
            local child = workspace:FindFirstChild("GrabParts")
            if child and child.Name == "GrabParts" then
                local grabPart = child:FindFirstChild("GrabPart")
                local grabbedPart = grabPart:FindFirstChild("WeldConstraint").Part1
                local head = grabbedPart.Parent:FindFirstChild("Head")
                if head then
                    while workspace:FindFirstChild("GrabParts") do
                        local partsTable = grabType == "poison" and poisonHurtParts or paintPlayerParts
                        for _, part in pairs(partsTable) do
                            part.Size = Vector3.new(2, 2, 2)
                            part.Transparency = 1
                            part.Position = head.Position
                        end
                        wait()
                        for _, part in pairs(partsTable) do
                            part.Position = Vector3.new(0, -200, 0)
                        end
                    end
                    for _, part in pairs(partsTable) do
                        part.Position = Vector3.new(0, -200, 0)
                    end
                end
            end
        end)
        wait()
    end
end

local function fireGrab()
    while true do
        local success, err = pcall(function()
            local child = workspace:FindFirstChild("GrabParts")
            if child and child.Name == "GrabParts" then
                local grabPart = child:FindFirstChild("GrabPart")
                local grabbedPart = grabPart:FindFirstChild("WeldConstraint").Part1
                local head = grabbedPart.Parent:FindFirstChild("Head")
                if head then
                    arson(head)
                end
            end
        end)
        wait()
    end
end

local function noclipGrab()
    while true do
        local success, err = pcall(function()
            local child = workspace:FindFirstChild("GrabParts")
            if child and child.Name == "GrabParts" then
                local grabPart = child:FindFirstChild("GrabPart")
                local grabbedPart = grabPart:FindFirstChild("WeldConstraint").Part1
                local character = grabbedPart.Parent
                if character.HumanoidRootPart then
                    while workspace:FindFirstChild("GrabParts") do
                        for _, part in pairs(character:GetChildren()) do
                            if part:IsA("BasePart") then
                                part.CanCollide = false
                            end
                        end
                        wait()
                    end
                    for _, part in pairs(character:GetChildren()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = true
                        end
                    end
                end
            end
        end)
        wait()
    end
end

local function spawnItemCf(itemName, cframe)
    task.spawn(function()
        local rotation = Vector3.new(0, 0, 0)
        ReplicatedStorage.MenuToys.SpawnToyRemoteFunction:InvokeServer(itemName, cframe, rotation)
    end)
end

local function fireAll()
    while true do
        local success, err = pcall(function()
            if toysFolder:FindFirstChild("Campfire") then
                DestroyT(toysFolder:FindFirstChild("Campfire"))
                wait(0.5)
            end
            spawnItemCf("Campfire", playerCharacter.Head.CFrame)
            local campfire = toysFolder:WaitForChild("Campfire")
            local firePlayerPart
            for _, part in pairs(campfire:GetChildren()) do
                if part.Name == "FirePlayerPart" then
                    part.Size = Vector3.new(10, 10, 10)
                    firePlayerPart = part
                    break
                end
            end
            local originalPosition = playerCharacter.Torso.Position
            SetNetworkOwner:FireServer(firePlayerPart, firePlayerPart.CFrame)
            playerCharacter:MoveTo(firePlayerPart.Position)
            wait(0.3)
            playerCharacter:MoveTo(originalPosition)
            local bodyPosition = Instance.new("BodyPosition")
            bodyPosition.P = 20000
            bodyPosition.Position = playerCharacter.Head.Position + Vector3.new(0, 600, 0)
            bodyPosition.Parent = campfire.Main
            while true do
                for _, player in pairs(Players:GetChildren()) do
                    pcall(function()
                        bodyPosition.Position = playerCharacter.Head.Position + Vector3.new(0, 600, 0)
                        if player.Character and player.Character.HumanoidRootPart and player.Character ~= playerCharacter then
                            firePlayerPart.Position = player.Character.HumanoidRootPart.Position or player.Character.Head.Position
                            wait()
                        end
                    end)
                end  
                wait()
            end
        end)
        if not success then
            warn("Error in fireAll: " .. tostring(err))
        end
        wait()
    end
end

local function createHighlight(parent)
    local highlight = Instance.new("Highlight")
    highlight.DepthMode = Enum.HighlightDepthMode.Occluded
    highlight.FillTransparency = 1
    highlight.Name = "Highlight"
    highlight.OutlineColor = Color3.new(0, 0, 1)
    highlight.OutlineTransparency = 0.5
    highlight.Parent = parent
    return highlight
end

local function createBodyMovers(part, position, rotation)
    local bodyPosition = Instance.new("BodyPosition")
    local bodyGyro = Instance.new("BodyGyro")

    bodyPosition.P = 15000
    bodyPosition.D = 200
    bodyPosition.MaxForce = Vector3.new(5000000, 5000000, 5000000)
    bodyPosition.Position = position
    bodyPosition.Parent = part

    bodyGyro.P = 15000
    bodyGyro.D = 200
    bodyGyro.MaxTorque = Vector3.new(5000000, 5000000, 5000000)
    bodyGyro.CFrame = rotation
    bodyGyro.Parent = part
end

local function anchorGrab()
    while true do
        pcall(function()
            local grabParts = workspace:FindFirstChild("GrabParts")
            if not grabParts then return end

            local grabPart = grabParts:FindFirstChild("GrabPart")
            if not grabPart then return end

            local weldConstraint = grabPart:FindFirstChild("WeldConstraint")
            if not weldConstraint or not weldConstraint.Part1 then return end

            local primaryPart = weldConstraint.Part1.Name == "SoundPart" and weldConstraint.Part1 or weldConstraint.Part1.Parent.SoundPart or weldConstraint.Part1.Parent.PrimaryPart or weldConstraint.Part1
            if not primaryPart then return end
            if primaryPart.Anchored then return end

            if isDescendantOf(primaryPart, workspace.Map) then return end
            for _, player in pairs(Players:GetChildren()) do
                if isDescendantOf(primaryPart, player.Character) then return end
            end
            
            if not table.find(anchoredParts, primaryPart) then
                local target = primaryPart
                if primaryPart.Parent:IsA("Model") and primaryPart.Parent ~= workspace then
                    target = primaryPart.Parent
                end

                local highlight = createHighlight(target)
                table.insert(anchoredParts, primaryPart)
                
                if primaryPart.Parent:IsA("Model") and primaryPart.Parent ~= workspace then 
                    for _, child in ipairs(primaryPart.Parent:GetDescendants()) do
                        if child:IsA("BodyPosition") or child:IsA("BodyGyro") then
                            child:Destroy()
                        end
                    end
                else
                    for _, child in ipairs(primaryPart:GetChildren()) do
                        if child:IsA("BodyPosition") or child:IsA("BodyGyro") then
                            child:Destroy()
                        end
                    end
                end

                while workspace:FindFirstChild("GrabParts") do
                    wait()
                end
                createBodyMovers(primaryPart, primaryPart.Position, primaryPart.CFrame)
            end
        end)
        wait()
    end
end

local function anchorKickGrab()
    while true do
        pcall(function()
            local grabParts = workspace:FindFirstChild("GrabParts")
            if not grabParts then return end

            local grabPart = grabParts:FindFirstChild("GrabPart")
            if not grabPart then return end

            local weldConstraint = grabPart:FindFirstChild("WeldConstraint")
            if not weldConstraint or not weldConstraint.Part1 then return end

            local primaryPart = weldConstraint.Part1
            if not primaryPart then return end

            if isDescendantOf(primaryPart, workspace.Map) then return end
            if primaryPart.Name ~= "FirePlayerPart" then return end

            for _, child in ipairs(primaryPart:GetChildren()) do
                if child:IsA("BodyPosition") or child:IsA("BodyGyro") then
                    child:Destroy()
                end
            end

            while workspace:FindFirstChild("GrabParts") do
                wait()
            end
            createBodyMovers(primaryPart, primaryPart.Position, primaryPart.CFrame)
        end)
        wait()
    end
end

local function cleanupAnchoredParts()
    for _, part in ipairs(anchoredParts) do
        if part then
            if part:FindFirstChild("BodyPosition") then
                part.BodyPosition:Destroy()
            end
            if part:FindFirstChild("BodyGyro") then
                part.BodyGyro:Destroy()
            end
            local highlight = part:FindFirstChild("Highlight") or part.Parent and part.Parent:FindFirstChild("Highlight")
            if highlight then
                highlight:Destroy()
            end
        end
    end
    anchoredParts = {}
end

local function recoverParts()
    while true do
        local success, err = pcall(function()
            local character = localPlayer.Character
            if character and character:FindFirstChild("Head") and character:FindFirstChild("HumanoidRootPart") then
                local head = character.Head
                local humanoidRootPart = character.HumanoidRootPart

                for _, partModel in pairs(anchoredParts) do
                    coroutine.wrap(function()
                        if partModel then
                            local distance = (partModel.Position - humanoidRootPart.Position).Magnitude
                            if distance <= 30 then
                                local highlight = partModel:FindFirstChild("Highlight") or partModel.Parent:FindFirstChild("Highlight")
                                if highlight and highlight.OutlineColor == Color3.new(1, 0, 0) then
                                    SetNetworkOwner:FireServer(partModel, partModel.CFrame)
                                    if partModel:WaitForChild("PartOwner") and partModel.PartOwner.Value == localPlayer.Name then
                                        highlight.OutlineColor = Color3.new(0, 0, 1)
                                    end
                                end
                            end
                        end
                    end)()
                end
            end
        end)
        wait(0.02)
    end
end

local function ragdollAll()
    while true do
        local success, err = pcall(function()
            if not toysFolder:FindFirstChild("FoodBanana") then
                spawnItem("FoodBanana", Vector3.new(-72.9304581, -5.96906614, -265.543732))
            end
            local banana = toysFolder:WaitForChild("FoodBanana")
            local bananaPeel
            for _, part in pairs(banana:GetChildren()) do
                if part.Name == "BananaPeel" and part:FindFirstChild("TouchInterest") then
                    part.Size = Vector3.new(10, 10, 10)
                    part.Transparency = 1
                    bananaPeel = part
                    break
                end
            end
            local bodyPosition = Instance.new("BodyPosition")
            bodyPosition.P = 20000
            bodyPosition.Parent = banana.Main
            while true do
                for _, player in pairs(Players:GetChildren()) do
                    pcall(function()
                        if player.Character and player.Character ~= playerCharacter then
                            bananaPeel.Position = player.Character.HumanoidRootPart.Position or player.Character.Head.Position
                            bodyPosition.Position = playerCharacter.Head.Position + Vector3.new(0, 600, 0)
                            wait()
                        end
                    end)
                end   
                wait()
            end
        end)
        if not success then
            warn("Error in ragdollAll: " .. tostring(err))
        end
        wait()
    end
end

local function reloadMissile(bool)
    if bool then
        if not ownedToys[_G.ToyToLoad] then
            Notify("Missing toy", "You do not own the ".._G.ToyToLoad.." toy.", 3)
            return
        end

        if not reloadBombCoroutine then
            reloadBombCoroutine = coroutine.create(function()
                local connectionBombReload = toysFolder.ChildAdded:Connect(function(child)
                    if child.Name == _G.ToyToLoad and child:WaitForChild("ThisToysNumber", 1) then
                        if child.ThisToysNumber.Value == (toysFolder.ToyNumber.Value - 1) then
                            local connection2
                            connection2 = toysFolder.ChildRemoved:Connect(function(child2)
                                if child2 == child then
                                    connection2:Disconnect()
                                end
                            end)

                            SetNetworkOwner:FireServer(child.Body, child.Body.CFrame)
                            local waiting = child.Body:WaitForChild("PartOwner", 0.5)
                            local connection = child.DescendantAdded:Connect(function(descendant)
                                if descendant.Name == "PartOwner" then
                                    if descendant.Value ~= localPlayer.Name then
                                        DestroyT(child)
                                        connection:Disconnect()
                                    end
                                end
                            end)
                            Debris:AddItem(connection, 60)
                            if waiting and waiting.Value == localPlayer.Name then
                                for _, v in pairs(child:GetChildren()) do
                                    if v:IsA("BasePart") then
                                        v.CanCollide = false
                                    end
                                end
                                child:SetPrimaryPartCFrame(CFrame.new(-72.9304581, -3.96906614, -265.543732))
                                wait(0.2)
                                for _, v in pairs(child:GetChildren()) do
                                    if v:IsA("BasePart") then
                                        v.Anchored = true
                                    end
                                end
                                table.insert(bombList, child)
                                child.AncestryChanged:Connect(function()
                                    if not child.Parent then
                                        for i, bomb in ipairs(bombList) do
                                            if bomb == child then
                                                table.remove(bombList, i)
                                                break
                                            end
                                        end
                                    end
                                end)
                                connection2:Disconnect()
                            else
                                DestroyT(child)
                            end
                        end
                    end
                end)

                while true do
                    if localPlayer.CanSpawnToy and localPlayer.CanSpawnToy.Value and #bombList < _G.MaxMissiles and playerCharacter:FindFirstChild("Head") then
                        spawnItemCf(_G.ToyToLoad, playerCharacter.Head.CFrame or playerCharacter.HumanoidRootPart.CFrame)
                    end
                    RunService.Heartbeat:Wait()
                end
            end)
            coroutine.resume(reloadBombCoroutine)
        end
    else
        if reloadBombCoroutine then
            coroutine.close(reloadBombCoroutine)
            reloadBombCoroutine = nil
        end
    end
end

local function setupAntiExplosion(character)
    local partOwner = character:WaitForChild("Humanoid"):FindFirstChild("Ragdolled")
    if partOwner then
        local partOwnerChangedConn
        partOwnerChangedConn = partOwner:GetPropertyChangedSignal("Value"):Connect(function()
            if partOwner.Value then
                for _, part in ipairs(character:GetChildren()) do
                    if part:IsA("BasePart") then
                        part.Anchored = true
                    end
                end
            else
                for _, part in ipairs(character:GetChildren()) do
                    if part:IsA("BasePart") then
                        part.Anchored = false
                    end
                end
            end
        end)
        antiExplosionConnection = partOwnerChangedConn
    end
end

local blobalter = 1
local function blobGrabPlayer(player, blobman)
    if blobalter == 1 then
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local args = {
                [1] = blobman:FindFirstChild("LeftDetector"),
                [2] = player.Character:FindFirstChild("HumanoidRootPart"),
                [3] = blobman:FindFirstChild("LeftDetector"):FindFirstChild("LeftWeld")
            }
            blobman:WaitForChild("BlobmanSeatAndOwnerScript"):WaitForChild("CreatureGrab"):FireServer(unpack(args))
            blobalter = 2
        end
    else
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local args = {
                [1] = blobman:FindFirstChild("RightDetector"),
                [2] = player.Character:FindFirstChild("HumanoidRootPart"),
                [3] = blobman:FindFirstChild("RightDetector"):FindFirstChild("RightWeld")
            }
            blobman:WaitForChild("BlobmanSeatAndOwnerScript"):WaitForChild("CreatureGrab"):FireServer(unpack(args))
            blobalter = 1
        end
    end
end

-- Создание вкладок
local homeTab = Window:Tab({Title = "Home", Icon = "home"})
local GrabTab = Window:Tab({Title = "Combat", Icon = "zap"})
local PlayerTab = Window:Tab({Title = "Local Player", Icon = "user"})
local ObjectGrabTab = Window:Tab({Title = "Object Grab", Icon = "package"})
local DefanseTab = Window:Tab({Title = "Anti Grab", Icon = "shield"})
local BlobmanTab = Window:Tab({Title = "Blob Man", Icon = "user-plus"})
local FunTab = Window:Tab({Title = "Fun / Troll", Icon = "smile"})
local ExplosionTab = Window:Tab({Title = "Explosions", Icon = "bomb"})

-- Home Tab
homeTab:Section({Title = "Welcome"})
homeTab:Label({
    Title = "Venom X",
    Desc = "Welcome to Venom X! "..localPlayer.Name.." Thanks for using script!"
})

-- Combat Tab
GrabTab:Section({Title = "Strength Settings"})
GrabTab:Slider({
    Title = "Strength Power",
    Desc = "Set throwing strength",
    Min = 300,
    Max = 10000,
    Value = 400,
    Callback = function(Value)
        _G.strength = Value
    end
})

local strengthEnabled = false
GrabTab:Toggle({
    Title = "Enable Strength",
    Desc = "Enable enhanced throwing",
    Value = false,
    Callback = function(enabled)
        strengthEnabled = enabled
        if enabled then
            strengthConnection = workspace.ChildAdded:Connect(function(model)
                if model.Name == "GrabParts" then
                    local partToImpulse = model.GrabPart.WeldConstraint.Part1
                    if partToImpulse then
                        local velocityObj = Instance.new("BodyVelocity", partToImpulse)
                        model:GetPropertyChangedSignal("Parent"):Connect(function()
                            if not model.Parent then
                                if UserInputService:GetLastInputType() == Enum.UserInputType.MouseButton2 then
                                    velocityObj.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                                    velocityObj.Velocity = workspace.CurrentCamera.CFrame.LookVector * _G.strength
                                    Debris:AddItem(velocityObj, 1)
                                else
                                    velocityObj:Destroy()
                                end
                            end
                        end)
                    end
                end
            end)
        elseif strengthConnection then
            strengthConnection:Disconnect()
        end
    end
})

GrabTab:Section({Title = "Grab Effects"})

local poisonGrabEnabled = false
GrabTab:Toggle({
    Title = "Poison Grab",
    Desc = "Apply poison effect when grabbing",
    Value = false,
    Callback = function(enabled)
        poisonGrabEnabled = enabled
        if enabled then
            poisonGrabCoroutine = coroutine.create(function()
                while poisonGrabEnabled do
                    pcall(function()
                        local child = workspace:FindFirstChild("GrabParts")
                        if child and child.Name == "GrabParts" then
                            local grabPart = child:FindFirstChild("GrabPart")
                            local grabbedPart = grabPart:FindFirstChild("WeldConstraint").Part1
                            local head = grabbedPart.Parent:FindFirstChild("Head")
                            if head then
                                while workspace:FindFirstChild("GrabParts") do
                                    for _, part in pairs(poisonHurtParts) do
                                        part.Size = Vector3.new(2, 2, 2)
                                        part.Transparency = 1
                                        part.Position = head.Position
                                    end
                                    task.wait()
                                    for _, part in pairs(poisonHurtParts) do
                                        part.Position = Vector3.new(0, -200, 0)
                                    end
                                end
                            end
                        end
                    end)
                    task.wait()
                end
            end)
            coroutine.resume(poisonGrabCoroutine)
        else
            if poisonGrabCoroutine then
                coroutine.close(poisonGrabCoroutine)
                poisonGrabCoroutine = nil
                for _, part in pairs(poisonHurtParts) do
                    part.Position = Vector3.new(0, -200, 0)
                end
            end
        end
    end
})

local radioactiveGrabEnabled = false
GrabTab:Toggle({
    Title = "Radioactive Grab",
    Desc = "Apply radioactive effect when grabbing",
    Value = false,
    Callback = function(enabled)
        radioactiveGrabEnabled = enabled
        if enabled then
            ufoGrabCoroutine = coroutine.create(function()
                while radioactiveGrabEnabled do
                    pcall(function()
                        local child = workspace:FindFirstChild("GrabParts")
                        if child and child.Name == "GrabParts" then
                            local grabPart = child:FindFirstChild("GrabPart")
                            local grabbedPart = grabPart:FindFirstChild("WeldConstraint").Part1
                            local head = grabbedPart.Parent:FindFirstChild("Head")
                            if head then
                                while workspace:FindFirstChild("GrabParts") do
                                    for _, part in pairs(paintPlayerParts) do
                                        part.Size = Vector3.new(2, 2, 2)
                                        part.Transparency = 1
                                        part.Position = head.Position
                                    end
                                    task.wait()
                                    for _, part in pairs(paintPlayerParts) do
                                        part.Position = Vector3.new(0, -200, 0)
                                    end
                                end
                            end
                        end
                    end)
                    task.wait()
                end
            end)
            coroutine.resume(ufoGrabCoroutine)
        else
            if ufoGrabCoroutine then
                coroutine.close(ufoGrabCoroutine)
                ufoGrabCoroutine = nil
                for _, part in pairs(paintPlayerParts) do
                    part.Position = Vector3.new(0, -200, 0)
                end
            end
        end
    end
})

local fireGrabEnabled = false
GrabTab:Toggle({
    Title = "Fire Grab",
    Desc = "Apply fire effect when grabbing",
    Value = false,
    Callback = function(enabled)
        fireGrabEnabled = enabled
        if enabled then
            fireGrabCoroutine = coroutine.create(function()
                while fireGrabEnabled do
                    pcall(function()
                        local child = workspace:FindFirstChild("GrabParts")
                        if child and child.Name == "GrabParts" then
                            local grabPart = child:FindFirstChild("GrabPart")
                            local grabbedPart = grabPart:FindFirstChild("WeldConstraint").Part1
                            local head = grabbedPart.Parent:FindFirstChild("Head")
                            if head then
                                arson(head)
                            end
                        end
                    end)
                    task.wait()
                end
            end)
            coroutine.resume(fireGrabCoroutine)
        else
            if fireGrabCoroutine then
                coroutine.close(fireGrabCoroutine)
                fireGrabCoroutine = nil
            end
        end
    end
})

local noclipGrabEnabled = false
GrabTab:Toggle({
    Title = "Noclip Grab",
    Desc = "Make grabbed player noclip",
    Value = false,
    Callback = function(enabled)
        noclipGrabEnabled = enabled
        if enabled then
            noclipGrabCoroutine = coroutine.create(function()
                while noclipGrabEnabled do
                    pcall(function()
                        local child = workspace:FindFirstChild("GrabParts")
                        if child and child.Name == "GrabParts" then
                            local grabPart = child:FindFirstChild("GrabPart")
                            local grabbedPart = grabPart:FindFirstChild("WeldConstraint").Part1
                            local character = grabbedPart.Parent
                            if character.HumanoidRootPart then
                                while workspace:FindFirstChild("GrabParts") do
                                    for _, part in pairs(character:GetChildren()) do
                                        if part:IsA("BasePart") then
                                            part.CanCollide = false
                                        end
                                    end
                                    task.wait()
                                end
                                for _, part in pairs(character:GetChildren()) do
                                    if part:IsA("BasePart") then
                                        part.CanCollide = true
                                    end
                                end
                            end
                        end
                    end)
                    task.wait()
                end
            end)
            coroutine.resume(noclipGrabCoroutine)
        else
            if noclipGrabCoroutine then
                coroutine.close(noclipGrabCoroutine)
                noclipGrabCoroutine = nil
            end
        end
    end
})

local kickGrabEnabled = false
GrabTab:Toggle({
    Title = "Kick Grab",
    Desc = "Enable kick grab effects",
    Value = false,
    Callback = function(enabled)
        kickGrabEnabled = enabled
        if enabled then
            kickGrab()
        else
            for _, connection in pairs(kickGrabConnections) do
                connection:Disconnect()
            end
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = player.Character.HumanoidRootPart
                    if hrp:FindFirstChild("FirePlayerPart") then
                        local fpp = hrp.FirePlayerPart
                        fpp.Size = Vector3.new(2.5, 5.5, 2.5)
                        fpp.CollisionGroup = "Default"
                        fpp.CanQuery = false
                    end
                end
            end
            kickGrabConnections = {}
        end
    end
})

local kickGrabAnchorEnabled = false
GrabTab:Toggle({
    Title = "Kick Grab Anchor",
    Desc = "Anchor kick grabbed players",
    Value = false,
    Callback = function(enabled)
        kickGrabAnchorEnabled = enabled
        if enabled then
            if not antiKickCoroutine or coroutine.status(antiKickCoroutine) == "dead" then
                antiKickCoroutine = coroutine.create(function()
                    while kickGrabAnchorEnabled do
                        pcall(anchorKickGrab)
                        task.wait()
                    end
                end)
                coroutine.resume(antiKickCoroutine)
            end
        else
            if antiKickCoroutine and coroutine.status(antiKickCoroutine) ~= "dead" then
                coroutine.close(antiKickCoroutine)
                antiKickCoroutine = nil
            end
        end
    end
})

local fireAllEnabled = false
GrabTab:Toggle({
    Title = "Fire All",
    Desc = "Fire effect on all players",
    Value = false,
    Callback = function(enabled)
        fireAllEnabled = enabled
        if enabled then
            fireAllCoroutine = coroutine.create(function()
                while fireAllEnabled do
                    pcall(fireAll)
                    task.wait()
                end
            end)
            coroutine.resume(fireAllCoroutine)
        else
            if fireAllCoroutine then
                coroutine.close(fireAllCoroutine)
                fireAllCoroutine = nil
            end
        end
    end
})

-- Local Player Tab
PlayerTab:Section({Title = "Movement"})

local crouchSpeedEnabled = false
PlayerTab:Toggle({
    Title = "Crouch Speed",
    Desc = "Increase speed while crouching",
    Value = false,
    Callback = function(enabled)
        crouchSpeedEnabled = enabled
        if enabled then
            crouchSpeedCoroutine = coroutine.create(function()
                while crouchSpeedEnabled do
                    pcall(function()
                        if not playerCharacter.Humanoid then return end
                        if playerCharacter.Humanoid.WalkSpeed == 5 then
                            playerCharacter.Humanoid.WalkSpeed = crouchWalkSpeed
                        end
                    end)
                    task.wait()
                end
            end)
            coroutine.resume(crouchSpeedCoroutine)
        elseif crouchSpeedCoroutine then
            coroutine.close(crouchSpeedCoroutine)
            crouchSpeedCoroutine = nil
            if playerCharacter.Humanoid then
                playerCharacter.Humanoid.WalkSpeed = 16
            end
        end
    end
})

PlayerTab:Slider({
    Title = "Set Crouch Speed",
    Desc = "Set crouch walking speed",
    Min = 6,
    Max = 1000,
    Value = 50,
    Callback = function(Value)
        crouchWalkSpeed = Value
    end
})

local crouchJumpEnabled = false
PlayerTab:Toggle({
    Title = "Crouch Jump Power",
    Desc = "Increase jump power while crouching",
    Value = false,
    Callback = function(enabled)
        crouchJumpEnabled = enabled
        if enabled then
            crouchJumpCoroutine = coroutine.create(function()
                while crouchJumpEnabled do
                    pcall(function()
                        if not playerCharacter.Humanoid then return end
                        if playerCharacter.Humanoid.JumpPower == 12 then
                            playerCharacter.Humanoid.JumpPower = crouchJumpPower
                        end
                    end)
                    task.wait()
                end
            end)
            coroutine.resume(crouchJumpCoroutine)
        elseif crouchJumpCoroutine then
            coroutine.close(crouchJumpCoroutine)
            crouchJumpCoroutine = nil
            if playerCharacter.Humanoid then
                playerCharacter.Humanoid.JumpPower = 24
            end
        end
    end
})

PlayerTab:Slider({
    Title = "Set Crouch Jump Power",
    Desc = "Set crouch jump power",
    Min = 6,
    Max = 1000,
    Value = 50,
    Callback = function(Value)
        crouchJumpPower = Value
    end
})

-- Object Grab Tab
ObjectGrabTab:Section({Title = "Anchor Grab"})

local anchorGrabEnabled = false
ObjectGrabTab:Toggle({
    Title = "Anchor Grab",
    Desc = "Anchor objects when grabbed",
    Value = false,
    Callback = function(enabled)
        anchorGrabEnabled = enabled
        if enabled then
            if not anchorGrabCoroutine or coroutine.status(anchorGrabCoroutine) == "dead" then
                anchorGrabCoroutine = coroutine.create(function()
                    while anchorGrabEnabled do
                        pcall(anchorGrab)
                        task.wait()
                    end
                end)
                coroutine.resume(anchorGrabCoroutine)
            end
        else
            if anchorGrabCoroutine and coroutine.status(anchorGrabCoroutine) ~= "dead" then
                coroutine.close(anchorGrabCoroutine)
                anchorGrabCoroutine = nil
            end
        end
    end
})

ObjectGrabTab:Button({
    Title = "Unanchor Parts",
    Desc = "Remove anchor from all parts",
    Callback = cleanupAnchoredParts
})

local autoRecoverEnabled = false
ObjectGrabTab:Toggle({
    Title = "Auto Recover Dropped Parts",
    Desc = "Automatically recover dropped parts",
    Value = false,
    Callback = function(enabled)
        autoRecoverEnabled = enabled
        if enabled then
            if not AutoRecoverDroppedPartsCoroutine or coroutine.status(AutoRecoverDroppedPartsCoroutine) == "dead" then
                AutoRecoverDroppedPartsCoroutine = coroutine.create(function()
                    while autoRecoverEnabled do
                        pcall(recoverParts)
                        task.wait(0.02)
                    end
                end)
                coroutine.resume(AutoRecoverDroppedPartsCoroutine)
            end
        else
            if AutoRecoverDroppedPartsCoroutine and coroutine.status(AutoRecoverDroppedPartsCoroutine) ~= "dead" then
                coroutine.close(AutoRecoverDroppedPartsCoroutine)
                AutoRecoverDroppedPartsCoroutine = nil
            end
        end
    end
})

-- Defense Tab
DefanseTab:Section({Title = "Anti-Grab"})

local antiGrabEnabled = false
DefanseTab:Toggle({
    Title = "Anti Grab",
    Desc = "Automatically struggle when grabbed",
    Value = false,
    Callback = function(enabled)
        antiGrabEnabled = enabled
        if enabled then
            autoStruggleCoroutine = RunService.Heartbeat:Connect(function()
                local character = localPlayer.Character
                if character and character:FindFirstChild("Head") then
                    local head = character.Head
                    local partOwner = head:FindFirstChild("PartOwner")
                    if partOwner then
                        Struggle:FireServer()
                        ReplicatedStorage.GameCorrectionEvents.StopAllVelocity:FireServer()
                        for _, part in pairs(character:GetChildren()) do
                            if part:IsA("BasePart") then
                                part.Anchored = true
                            end
                        end
                        while localPlayer.IsHeld.Value do
                            task.wait()
                        end
                        for _, part in pairs(character:GetChildren()) do
                            if part:IsA("BasePart") then
                                part.Anchored = false
                            end
                        end
                    end
                end
            end)
        else
            if autoStruggleCoroutine then
                autoStruggleCoroutine:Disconnect()
                autoStruggleCoroutine = nil
            end
        end
    end
})

local antiKickGrabEnabled = false
DefanseTab:Toggle({
    Title = "Anti Kick Grab",
    Desc = "Prevent being kick grabbed",
    Value = false,
    Callback = function(enabled)
        antiKickGrabEnabled = enabled
        if enabled then
            antiKickCoroutine = RunService.Heartbeat:Connect(function()
                local character = localPlayer.Character
                if character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("HumanoidRootPart"):FindFirstChild("FirePlayerPart") then
                    local partOwner = character:FindFirstChild("HumanoidRootPart"):FindFirstChild("FirePlayerPart"):FindFirstChild("PartOwner")
                    if partOwner and partOwner.Value ~= localPlayer.Name then
                        local args = {[1] = character:WaitForChild("HumanoidRootPart"), [2] = 0}
                        game:GetService("ReplicatedStorage"):WaitForChild("CharacterEvents"):WaitForChild("RagdollRemote"):FireServer(unpack(args))
                        task.wait(0.1)
                        Struggle:FireServer()
                    end
                end
            end)
        else
            if antiKickCoroutine then
                antiKickCoroutine:Disconnect()
                antiKickCoroutine = nil
            end
        end
    end
})

local antiExplosionEnabled = false
DefanseTab:Toggle({
    Title = "Anti Explosion",
    Desc = "Prevent explosion effects",
    Value = false,
    Callback = function(enabled)
        antiExplosionEnabled = enabled
        if enabled then
            if localPlayer.Character then
                setupAntiExplosion(localPlayer.Character)
            end
            local characterAddedConn = localPlayer.CharacterAdded:Connect(function(character)
                if antiExplosionConnection then
                    antiExplosionConnection:Disconnect()
                end
                setupAntiExplosion(character)
            end)
        else
            if antiExplosionConnection then
                antiExplosionConnection:Disconnect()
                antiExplosionConnection = nil
            end
        end
    end
})

DefanseTab:Section({Title = "Self Defense"})

local selfDefenseEnabled = false
DefanseTab:Toggle({
    Title = "Self Defense / Air Suspend",
    Desc = "Suspend attackers in air",
    Value = false,
    Callback = function(enabled)
        selfDefenseEnabled = enabled
        if enabled then
            autoDefendCoroutine = coroutine.create(function()
                while selfDefenseEnabled do
                    task.wait(0.02)
                    local character = localPlayer.Character
                    if character and character:FindFirstChild("Head") then
                        local head = character.Head
                        local partOwner = head:FindFirstChild("PartOwner")
                        if partOwner then
                            local attacker = Players:FindFirstChild(partOwner.Value)
                            if attacker and attacker.Character then
                                Struggle:FireServer()
                                SetNetworkOwner:FireServer(attacker.Character.Head or attacker.Character.Torso, attacker.Character.HumanoidRootPart.FirePlayerPart.CFrame)
                                task.wait(0.1)
                                local target = attacker.Character:FindFirstChild("Torso")
                                if target then
                                    local velocity = target:FindFirstChild("l") or Instance.new("BodyVelocity")
                                    velocity.Name = "l"
                                    velocity.Parent = target
                                    velocity.Velocity = Vector3.new(0, 50, 0)
                                    velocity.MaxForce = Vector3.new(0, math.huge, 0)
                                    Debris:AddItem(velocity, 100)
                                end
                            end
                        end
                    end
                end
            end)
            coroutine.resume(autoDefendCoroutine)
        else
            if autoDefendCoroutine then
                coroutine.close(autoDefendCoroutine)
                autoDefendCoroutine = nil
            end
        end
    end
})

-- Blobman Tab
BlobmanTab:Section({Title = "Blobman"})

local blobmanEnabled = false
local blobmanToggle = BlobmanTab:Toggle({
    Title = "Destroy Server",
    Desc = "Use blobman to grab all players",
    Value = false,
    Callback = function(enabled)
        blobmanEnabled = enabled
        if enabled then
            blobmanCoroutine = coroutine.create(function()
                local foundBlobman = false
                for i, v in pairs(workspace:GetDescendants()) do
                    if v.Name == "CreatureBlobman" then
                        if v:FindFirstChild("VehicleSeat") and v.VehicleSeat:FindFirstChild("SeatWeld") and isDescendantOf(v.VehicleSeat.SeatWeld.Part1, localPlayer.Character) then
                            blobman = v
                            foundBlobman = true
                            break
                        end
                    end
                end

                if not foundBlobman then
                    Notify("Error", "You must be mounted on a blobman!", 3)
                    blobmanToggle:Set(false)
                    blobman = nil
                    coroutine.close(blobmanCoroutine)
                    blobmanCoroutine = nil
                    return
                end

                while blobmanEnabled do
                    pcall(function()
                        for i, v in pairs(Players:GetChildren()) do
                            if blobman and v ~= localPlayer and blobmanEnabled then
                                blobGrabPlayer(v, blobman)
                                task.wait(_G.BlobmanDelay)
                            end
                        end
                    end)
                    task.wait(0.02)
                end
            end)
            coroutine.resume(blobmanCoroutine)
        else
            if blobmanCoroutine then
                coroutine.close(blobmanCoroutine)
                blobmanCoroutine = nil
                blobman = nil
            end
        end
    end
})

BlobmanTab:Slider({
    Title = "Destroy Server Speed",
    Desc = "Adjust grab speed",
    Min = 0.05,
    Max = 1,
    Value = 0.005,
    Callback = function(Value)
        _G.BlobmanDelay = Value
    end
})

-- Fun Tab
FunTab:Section({Title = "Troll"})

local coinAmount = ""
FunTab:Textbox({
    Title = "Number of coins",
    Desc = "Enter amount",
    Value = "",
    Placeholder = "Number",
    ClearText = false,
    Callback = function(Text)
        coinAmount = Text 
    end
})

FunTab:Button({
    Title = "Get Coin",
    Desc = "Set coin amount in GUI",
    Callback = function()
        local amount = tonumber(coinAmount) or 0 
        game.Players.LocalPlayer.PlayerGui.MenuGui.TopRight.CoinsFrame.CoinsDisplay.Coins.Text = tostring(amount)
        Notify("Success", "Set coins to "..amount, 3)
    end
})

FunTab:Section({Title = "Fun"})
FunTab:Slider({
    Title = "Decoy Offset",
    Desc = "Distance between decoys",
    Min = 1,
    Max = 10,
    Value = 5,
    Callback = function(Value)
        decoyOffset = Value
    end
})

local circleRadiusValue = "10"
FunTab:Textbox({
    Title = "Circle Radius",
    Desc = "Radius for surround mode",
    Value = "10",
    Placeholder = "Radius",
    ClearText = false,
    Callback = function(Value)
        circleRadiusValue = Value
        circleRadius = tonumber(Value) or 10
    end
})

-- Decoy system
local decoyConnections = {}
FunTab:Button({
    Title = "Decoy Follow",
    Desc = "Make decoys follow you",
    Callback = function()
        local decoys = {}
        for _, descendant in pairs(workspace:GetDescendants()) do
            if descendant:IsA("Model") and descendant.Name == "YouDecoy" then
                table.insert(decoys, descendant)
            end
        end
        local numDecoys = #decoys
        local midPoint = math.ceil(numDecoys / 2)

        local function updateDecoyPositions()
            for index, decoy in pairs(decoys) do
                local torso = decoy:FindFirstChild("Torso")
                if torso then
                    local bodyPosition = torso:FindFirstChild("BodyPosition")
                    local bodyGyro = torso:FindFirstChild("BodyGyro")
                    if bodyPosition and bodyGyro then
                        local targetPosition
                        if followMode then
                            if playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart") then
                                targetPosition = playerCharacter.HumanoidRootPart.Position
                                local offset = (index - midPoint) * decoyOffset
                                local forward = playerCharacter.HumanoidRootPart.CFrame.LookVector
                                local right = playerCharacter.HumanoidRootPart.CFrame.RightVector
                                targetPosition = targetPosition - forward * decoyOffset + right * offset
                            end
                        else
                            local nearestPlayer = getNearestPlayer()
                            if nearestPlayer and nearestPlayer.Character and nearestPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                local angle = math.rad((index - 1) * (360 / numDecoys))
                                targetPosition = nearestPlayer.Character.HumanoidRootPart.Position + Vector3.new(math.cos(angle) * circleRadius, 0, math.sin(angle) * circleRadius)
                                bodyGyro.CFrame = CFrame.new(torso.Position, nearestPlayer.Character.HumanoidRootPart.Position)
                            end
                        end

                        if targetPosition then
                            local distance = (targetPosition - torso.Position).Magnitude
                            if distance > stopDistance then
                                bodyPosition.Position = targetPosition
                                if followMode then
                                    bodyGyro.CFrame = CFrame.new(torso.Position, targetPosition)
                                end
                            else
                                bodyPosition.Position = torso.Position
                                bodyGyro.CFrame = torso.CFrame
                            end
                        end
                    end
                end
            end
        end

        local function setupDecoy(decoy)
            local torso = decoy:FindFirstChild("Torso")
            if torso then
                local bodyPosition = Instance.new("BodyPosition")
                local bodyGyro = Instance.new("BodyGyro")
                bodyPosition.Parent = torso
                bodyGyro.Parent = torso
                bodyPosition.MaxForce = Vector3.new(40000, 40000, 40000)
                bodyPosition.D = 100
                bodyPosition.P = 100
                bodyGyro.MaxTorque = Vector3.new(40000, 40000, 40000)
                bodyGyro.D = 100
                bodyGyro.P = 20000
                local connection = RunService.Heartbeat:Connect(function()
                    updateDecoyPositions()
                end)
                table.insert(decoyConnections, connection)
                SetNetworkOwner:FireServer(torso, playerCharacter.Head.CFrame)
            end
        end

        for _, decoy in pairs(decoys) do
            setupDecoy(decoy)
        end
        Notify("Success", "Got "..numDecoys.." decoys", 5)
    end
})

FunTab:Button({
    Title = "Toggle Mode",
    Desc = "Toggle between follow and surround",
    Callback = function()
        followMode = not followMode
        Notify("Mode Changed", followMode and "Follow Mode" or "Surround Mode", 2)
    end
})

FunTab:Button({
    Title = "Disconnect Clones",
    Desc = "Stop controlling decoys",
    Callback = function()
        cleanupConnections(decoyConnections)
        Notify("Success", "Decoys disconnected", 3)
    end
})

local ragdollAllEnabled = false
FunTab:Toggle({
    Title = "Ragdoll All",
    Desc = "Ragdoll all players",
    Value = false,
    Callback = function(enabled)
        ragdollAllEnabled = enabled
        if enabled then
            ragdollAllCoroutine = coroutine.create(function()
                while ragdollAllEnabled do
                    pcall(ragdollAll)
                    task.wait()
                end
            end)
            coroutine.resume(ragdollAllCoroutine)
        else
            if ragdollAllCoroutine then
                coroutine.close(ragdollAllCoroutine)
                ragdollAllCoroutine = nil
            end
        end
    end
})

-- Explosion Tab
ExplosionTab:Section({Title = "Missile Settings"})

local toyName = "BombMissile"
ExplosionTab:Textbox({
    Title = "Toy to Load",
    Desc = "Enter toy name",
    Value = "BombMissile",
    Placeholder = "Toy Name",
    ClearText = false,
    Callback = function(Text)
        toyName = Text
        _G.ToyToLoad = Text
    end
})

ExplosionTab:Slider({
    Title = "Max Missiles",
    Desc = "Maximum missiles to store",
    Min = 1,
    Max = 20,
    Value = 9,
    Callback = function(Value)
        _G.MaxMissiles = Value
    end
})

local autoReloadEnabled = false
ExplosionTab:Toggle({
    Title = "Auto Reload Missiles",
    Desc = "Automatically reload missiles",
    Value = false,
    Callback = function(enabled)
        autoReloadEnabled = enabled
        reloadMissile(enabled)
    end
})
-- ВКЛАДКА CREDITS
local Tab8 = Window:Tab({Title = "👤 Credits", Icon = "heart"})

Tab8:Section({Title = "👑 Разработчики"})

Tab8:Label({
    Title = "👤 Saul Goodman",
    Desc = "Создатель и главный разработчик\nTelegram: @SaulGoodmanScript"
})

Tab8:Button({
    Title = "📋 Копировать Telegram",
    Callback = function()
        setclipboard("https://t.me/SaulGoodmanScript")
        Window:Notify({
            Title = "📋 Скопировано",
            Desc = "Ссылка скопирована",
            Time = 3
        })
    end
})

Tab8:Label({
    Title = "🤝 Lori Script",
    Desc = "Партнер проекта\nTelegram: @loriscript"
})

Tab8:Button({
    Title = "📋 Копировать Telegram",
    Callback = function()
        setclipboard("https://t.me/loriscript")
        Window:Notify({
            Title = "📋 Скопировано",
            Desc = "Ссылка скопирована",
            Time = 3
        })
    end
})